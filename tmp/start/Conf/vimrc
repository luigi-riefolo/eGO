" let's make sure we are in noncompatble mode
set nocp

let mapleader=","

" Fast saving
map <Leader>w :w<CR>
imap <Leader>w <ESC>:w<CR>
vmap <Leader>w <ESC><ESC>:w<CR>

" :W sudo saves the file
" (useful for handling the permission-denied error)
command W w !sudo tee % > /dev/null

" This is totally awesome - remap jj to escape in insert mode.  You'll never type jj anyway, so it's great!
inoremap jj <esc>
nnoremap JJJJ <nop>

" add vertical lines on columns
set colorcolumn=80,120

" Avoid garbled characters in Chinese language windows OS
let $LANG='en'
set langmenu=en
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim


vnoremap <C-c> "*y


" Turn on the WiLd menu
set wildmenu

" Set command-line completion mode
set wildmode=list:longest,full

" Highlight current line - allows you to track cursor position more easily
set cursorline

" Completion options (select longest + show menu even if a single match is found)
set completeopt=longest,menuone

" Ignore compiled files
set wildignore=*.o,*~,*.pyc
if has("win16") || has("win32")
    set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store
else
    set wildignore+=.git\*,.hg\*,.svn\*
endif

" Show line, column number, and relative position within a file in the status line
set ruler

" Show line numbers - could be toggled on/off on-fly by pressing F6
set number

" Show (partial) commands (or size of selection in Visual mode) in the status line
set showcmd

" A buffer becomes hidden when it is abandoned
set hid

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

" Allow smarter completion by infering the case
set infercase

" Ignore case when searching
set ignorecase

set smartcase

" When searching try to be smart about cases
set smartcase

" Highlight search results
set hlsearch

" Makes search act like search in modern browsers
set incsearch

" For regular expressions turn magic on
set magic

" Show matching brackets when text indicator is over them
set showmatch

" How many tenths of a second to blink when matching brackets
set mat=2

" No annoying sound on errors
set noerrorbells
set novisualbell
set t_vb=
set tm=500

" Make sure that extra margin on left is removed
set foldcolumn=0

" Enable Ctrl-A/Ctrl-X to work on octal and hex numbers, as well as characters
set nrformats=octal,hex,alpha

try
    colorscheme desert
catch
endtry

set background=dark

" Set extra options when running in GUI mode
if has("gui_running")
    set guioptions-=T
    set guioptions-=e
    set t_Co=256
    set guitablabel=%M\ %t
endif

" highlight trailing space
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Remember things between sessions
"
" '20  - remember marks for 20 previous files
" \"50 - save 50 lines for each register
" :20  - remember 20 items in command-line history
" /20  - remember 20 items in search history
" %    - remember the buffer list (if vim started without a file arg)
" n    - set name of viminfo file
set viminfo='20,\"50,:20,/20,%,n~/.viminfo.go

" Define what to save with :mksession
" blank - empty windows
" buffers - all buffers not only ones in a window
" curdir - the current directory
" folds - including manually created ones
" help - the help window
" options - all options and mapping
" winsize - window sizes
" tabpages - all tab pages
set sessionoptions=blank,buffers,curdir,folds,help,options,winsize,tabpages

" Round indent to multiple of 'shiftwidth' for > and < commands
set shiftround

" Linebreak on 500 characters
set lbr
set tw=500

set ai "Auto indent
set si "Smart indent
set nowrap "Don't Wrap lines (it is stupid)

" Return to last edit position when opening files (You want this!)
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"" |
     \ endif
" Remember info about open buffers on close
set viminfo^=%

" Always show the status line
set laststatus=2

" Remap VIM 0 to first non-blank character
map 0 ^

" Delete trailing white space on save, useful for Python and CoffeeScript ;)
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
autocmd BufWrite *.go :call DeleteTrailingWS()
autocmd BufWrite *.py :call DeleteTrailingWS()
autocmd BufWrite *.coffee :call DeleteTrailingWS()

" General properties
let NERDTreeDirArrows=1
let NERDTreeMinimalUI=1
let NERDTreeIgnore=['\.o$', '\.pyc$', '\.php\~$']
let NERDTreeWinSize = 35


" Make sure that when NT root is changed, Vim's pwd is also updated
let NERDTreeChDirMode = 2
let NERDTreeShowLineNumbers = 1
let NERDTreeAutoCenter = 1

" Open NERDTree on startup, when no file has been specified
autocmd VimEnter * if !argc() | NERDTree | endif
"autocmd VimEnter * if !argc() | NERDTreeProjectLoad project | endif
autocmd VimEnter * :NERDTreeProjectLoad project-1

"let NERDTreeQuitOnOpen=1

" Locate file in hierarchy quickly
map <leader>T :NERDTreeFind<cr>

" Toogle on/off
nmap <leader>o :NERDTreeToggle<cr>

let g:syntastic_aggregate_errors = 1

" Disable AutoComplPop.
let g:acp_enableAtStartup = 0

" Use neocomplete.
let g:neocomplete#enable_at_startup = 1

" Use smartcase.
let g:neocomplete#enable_smart_case = 1

" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 2

" AutoComplPop like behavior.
let g:neocomplete#enable_auto_select = 1

let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
"if !exists('g:neocomplete#sources#omni#input_patterns')
"  let g:neocomplete#sources#omni#input_patterns = {}
"endif
"let g:neocomplete#force_omni_input_patterns.go = '[^.[:digit:] *\t]\.'
if !exists('g:neocomplete#force_omni_input_patterns')
  let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.go = '[^.[:digit:] *\t]\.'

" By default syntax-highlighting for Functions, Methods and Structs is disabled.
" Let's enable them!
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_structs = 1
let g:go_highlight_types = 1
let g:go_highlight_fields = 1
let g:go_highlight_extra_types = 1
let g:go_highlight_build_constraints = 1
let g:go_highlight_generate_tags = 1

" Close NerdTree on exit
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" vim: set ft=vim :
set encoding=utf-8

colorscheme basic-dark

" Use Unix as the standard file type
set ffs=unix,dos,mac

syntax on

" Helps force plugins to load correctly when it is turned back on below
filetype off

" For plugins to load correctly
filetype plugin indent on

imap ^[OA <ESC>kli
imap ^[OB <ESC>jli
imap ^[OC <ESC>lli
imap ^[OD <ESC>hli

set tabstop=4
set shiftwidth=4
set softtabstop=4
set expandtab
set smarttab
set textwidth=79
set autoindent
set smartindent
set wrap


" Configure backspace so it acts as it should act
set backspace=indent,eol,start

" Set to auto read when a file is changed from the outside
set autoread

" Ignore case when searching
set ignorecase

" Ignore compiled files
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store

" When searching try to be smart about cases
set smartcase

" Highlight search results
set hlsearch

" Makes search act like search in modern browsers
set incsearch

" For regular expressions turn magic on
set magic

" Show matching brackets when text indicator is over them
set showmatch

" No annoying sound on errors
set noerrorbells
set novisualbell
"set t_vb=
"set tm=500

" Visual mode pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :<C-u>call VisualSelection('', '')<CR>/<C-R>=@/<CR><CR>
vnoremap <silent> # :<C-u>call VisualSelection('', '')<CR>?<C-R>=@/<CR><CR>


" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

" The following are examples of different formats supported.
" Keep Plugin commands between vundle#begin/end.
" plugin on GitHub repo
" Plugin 'tpope/vim-fugitive'
" plugin from http://vim-scripts.org/vim/scripts.html
" Plugin 'L9'
" Git plugin not hosted on GitHub
" Plugin 'git://git.wincent.com/command-t.git'
" git repos on your local machine (i.e. when working on your own plugin)
" Plugin 'file:///home/gmarik/path/to/plugin'
" The sparkup vim script is in a subdirectory of this repo called vim.
" Pass the path to set the runtimepath properly.
" Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
" Install L9 and avoid a Naming conflict if you've already installed a
" different version somewhere else.
" Plugin 'ascenator/L9', {'name': 'newL9'}


Plugin 'pangloss/vim-javascript'

Plugin 'maksimr/vim-jsbeautify'

Plugin 'fatih/vim-go'

Plugin 'scrooloose/syntastic'

Plugin 'nathanaelkane/vim-indent-guides'

Plugin 'jelera/vim-javascript-syntax'

"Plugin 'valloric/youcompleteme'

Plugin 'nvie/vim-flake8'

Plugin 'tpope/vim-surround'

Plugin 'bling/vim-airline'

Plugin 'vim-airline/vim-airline-themes'

Plugin 'Shougo/neocomplcache.vim'

Plugin 'shougo/neocomplete.vim'

Plugin 'Shougo/neosnippet'

Plugin 'Shougo/neosnippet-snippets'

Plugin 'bash-support.vim'

Plugin 'scrooloose/nerdtree'

Plugin 'airblade/vim-gitgutter'

Plugin 'vim-perl/vim-perl'

Plugin 'xolox/vim-misc'

Plugin 'xolox/vim-session'

Plugin 'nsf/gocode', {'rtp': 'vim/'}

Plugin 'ekalinin/Dockerfile.vim'


" All of your Plugins must be added before the following line
call vundle#end()


"set foldmethod=syntax
let g:javascript_plugin_flow = 1
let g:javascript_plugin_ngdoc = 1
let g:javascript_plugin_jsdoc = 1

autocmd FileType go nmap <Leader>i <Plug>(go-info)

map <F2> :retab <CR> :wq! <CR>
autocmd FileType go setlocal shiftwidth=8 tabstop=8

" Remove trailing spaces
autocmd BufWritePre * :%s/\s\+$//e

autocm BufWritePre *.json :%!python -m json.tool

execute pathogen#infect()

"
" Brief help
" :PluginList       - lists configured plugins
":source %
" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"
" see :h vundle for more details or wiki for FAQ
" Put your non-Plugin stuff after this line

" Vim-Session
let g:session_autoload = 'yes'
let g:session_autosave = 'yes'


" Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 1
"let g:syntastic_go_checkers = ['golint', 'vet', 'errcheck']
"let g:syntastic_go_checkers = ['gometalinter']
"let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go'] }
let g:go_metalinter_autosave_enabled = ['golint', 'errcheck', 'varcheck', 'vet']
let g:go_metalinter_enabled = ['vet', 'golint', 'errcheck', 'varcheck', 'aligncheck', 'structcheck', 'gosimple', 'staticcheck', 'constcheck']
let g:syntastic_python_checkers = ['pylint', 'flake8']
let g:syntastic_cpp_checkers = ['gcc']
let g:syntastic_html_checkers = ['JSHint', 'tidy']
let g:syntastic_javascript_checkers = ['JSHint']
let g:syntastic_css_checkers = ['csslint', 'prettycss']
let g:syntastic_css_checkers = ['prettycss']

" Vim-go
let g:go_fmt_command = "goimports"
let g:go_list_type = "quickfix"
let g:go_metalinter_autosave = 1
"let g:go_metalinter_autosave_enabled = ['gometalinter']
let g:go_auto_type_info = 1
let g:go_test_timeout = '50s'
let g:neocomplete#enable_at_startup = 1

" Bash
let g:BASH_AuthorName = 'Luigi Riefolo'
let g:BASH_Email = 'luigi.riefolo@simplesurance.de'
let g:BASH_Company = 'Simplesurance'


"nnoremap <C-w>E :SyntasticCheck<CR> :SyntasticToggleMode<CR>
nnoremap <F7> :SyntasticCheck<CR> :lopen<CR>
nnoremap <F8> :SyntasticToggleMode<CR>
autocmd FileType python map <buffer> <F5> :call Flake8()<CR>


map <c-f> :call JsBeautify()<cr>
" or
autocmd FileType javascript noremap <buffer>  <c-f> :call JsBeautify()<cr>
" for json
autocmd FileType json noremap <buffer> <c-f> :call JsonBeautify()<cr>
" for jsx
autocmd FileType jsx noremap <buffer> <c-f> :call JsxBeautify()<cr>
" for html
autocmd FileType html noremap <buffer> <c-f> :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <c-f> :call CSSBeautify()<cr>
" for go
"autocmd BufWritePost *.go :GoMetaLinter


" Python configuration
let python_highlight_all = 1
autocmd BufWritePost *.py call Flake8()
"autocmd VimEnter *.log AnsiEsc


"hi SpellBad ctermfg=088 ctermbg=094 guifg=#aaaaaa guibg=#bbbbbb
"hi SpellCap ctermfg=088 ctermbg=094 guifg=#aaaaaa guibg=#bbbbbb

"au BufNewFile,BufRead *.py
"    \ set tabstop=4 |



















" Usage:
"
"   Create a project from the current nerdtree with
"     :NERDTreeProjectSave <name>
"
"   Load a project with
"     :NERDTreeProjectLoad <name>
"
"   Delete a project with
"     :NERDTreeProjectRm <name>
"
"   Note: <name> above will tab complete.
"
"
" Tree state (open/closed dirs) will be remembered when you return to a
" project.
"
"============================================================

if exists("g:loaded_nerdtree_project_plugin")
    finish
endif
let g:loaded_nerdtree_project_plugin=1


"Glue code - wiring up s:Project into nerdtree
"============================================================
command! -nargs=1 NERDTreeProjectSave call g:NERDTreeProject.Add(<q-args>, b:NERDTree)
command! -nargs=1 -complete=customlist,NERDTreeCompleteProjectNames NERDTreeProjectLoad call g:NERDTreeProject.Open(<q-args>)
command! -nargs=1 -complete=customlist,NERDTreeCompleteProjectNames NERDTreeProjectRm call g:NERDTreeProject.Remove(<q-args>)

function! NERDTreeCompleteProjectNames(A,L,P) abort
    if empty(s:Project.All())
        return 0
    endif
    let names = map(copy(s:Project.All()), 'v:val.getName()')
    return filter(names, 'v:val =~# "^' . a:A . '"')
endfunction

augroup nerdtreeproject
    autocmd bufunload,bufwipeout * call g:NERDTreeProject.UpdateProjectInBuf(bufnr(bufname(expand("<afile>"))))
augroup end


"CLASS: Project
"============================================================
let s:Project = {}
let g:NERDTreeProject = s:Project

"Class Methods
"============================================================
" FUNCTION: Project.Add(name, nerdtree) {{{1
function! s:Project.Add(name, nerdtree) abort
    for i in s:Project.All()
        if i.getName() ==# a:name
            return i.update(a:nerdtree)
        endif
    endfor

    let newProj = s:Project.New(a:name, a:nerdtree)
    call add(s:Project.All(), newProj)
    call s:Project.Write()
    call newProj.open()
endfunction

" FUNCTION: Project.All() {{{1
function! s:Project.All() abort
    if !exists("s:Project._All")
        let s:Project._All = []
        call s:Project.Read()
    endif
    return s:Project._All
endfunction

" FUNCTION: Project.Remove() {{{1
function! s:Project.Remove(name) abort
    for i in s:Project.All()
        if i.getName() ==# a:name
            let idx = index(s:Project.All(), i)
            call remove(s:Project.All(), idx)
            call s:Project.Write()
            return nerdtree#echo("Project removed.")
        endif
    endfor
    call nerdtree#echo("No project found with name: '" . a:name . "'")
endfunction

" FUNCTION: Project.New(name, nerdtree) {{{1
function! s:Project.New(name, nerdtree, ...) abort
    if a:name =~# ' '
        throw "NERDTree.IllegalProjectNameError: illegal name:" . a:name
    endif

    let newObj = copy(self)
    let newObj._name = a:name
    let newObj._rootPath = a:nerdtree.root.path

    let opts = a:0 ? a:1 : {}
    if has_key(opts, 'openDirs')
        let newObj._openDirs = opts['openDirs']
    else
        let newObj._openDirs = newObj._extractOpenDirs(a:nerdtree.root)
    endif

    return newObj
endfunction

" FUNCTION: Project.FindByName(name) {{{1
function! s:Project.FindByName(name) abort
    for i in s:Project.All()
        if i.getName() ==# a:name
            return i
        endif
    endfor
    throw "NERDTree.NoProjectError: no project found for name: \"". a:name  .'"'
endfunction

" FUNCTION: Project.Open(name) {{{1
function! s:Project.Open(name) abort
    call s:Project.FindByName(a:name).open()
endfunction

" FUNCTION: Project.ProjectFileName() {{{1
function! s:Project.ProjectFileName() abort
    return expand("~/.NERDTreeProjects")
endfunction

" FUNCTION: Project.Read() {{{1
function! s:Project.Read() abort
    if !filereadable(s:Project.ProjectFileName())
        return []
    endif

    exec "let projHashes = " . readfile(s:Project.ProjectFileName())[0]

    for projHash in projHashes
        let nerdtree = g:NERDTree.New(g:NERDTreePath.New(projHash['rootPath']), "tab")
        let project = s:Project.New(projHash['name'], nerdtree, { 'openDirs': projHash['openDirs']})
        call add(s:Project.All(), project)
    endfor
endfunction

" FUNCTION: Project.UpdateProjectInBuf(bufnr) {{{1
function! s:Project.UpdateProjectInBuf(bufnr) abort
    let nerdtree = getbufvar(a:bufnr, "NERDTree")

    if empty(nerdtree)
        return
    endif

    if !has_key(nerdtree, '__currentProject')
        return
    endif

    let proj = nerdtree.__currentProject

    call proj.update(nerdtree)
endfunction

" FUNCTION: Project.Write() {{{1
function! s:Project.Write() abort
    let projHashes = []

    for proj in s:Project.All()
        let hash = {
            \ 'name': proj.getName(),
            \ 'openDirs': proj.getOpenDirs(),
            \ 'rootPath': proj.getRootPath().str()
        \ }

        call add(projHashes, hash)
    endfor

    call writefile([string(projHashes)], s:Project.ProjectFileName())
endfunction

"Instance Methods
"============================================================

" FUNCTION: Project.extractOpenDirs(rootNode) {{{1
function! s:Project._extractOpenDirs(rootNode) abort
    let retVal = []

    for node in a:rootNode.getDirChildren()
        if node.isOpen
            call add(retVal, node.path.str())

            let childOpenDirs = self._extractOpenDirs(node)
            if !empty(childOpenDirs)
                let retVal = retVal + childOpenDirs
            endif
        endif
    endfor

    return retVal
endfunction

" FUNCTION: Project.getName() {{{1
function! s:Project.getName() abort
    return self._name
endfunction

" FUNCTION: Project.getOpenDirs() {{{1
function! s:Project.getOpenDirs() abort
    return self._openDirs
endfunction

" FUNCTION: Project.getRoot() {{{1
function! s:Project.getRootPath() abort
    return self._rootPath
endfunction

" FUNCTION: Project.open() {{{1
function! s:Project.open() abort
    if g:NERDTree.IsOpen()
        call g:NERDTree.CursorToTreeWin()
    else
        call g:NERDTreeCreator.ToggleTabTree('')
    endif

    let newRoot = g:NERDTreeFileNode.New(self.getRootPath(), b:NERDTree)
    call b:NERDTree.changeRoot(newRoot)

    for dir in self.getOpenDirs()
        let p = g:NERDTreePath.New(dir)
        call b:NERDTree.root.reveal(p, { "open": 1 })
    endfor

    call b:NERDTree.render()
    let b:NERDTree.__currentProject = self
endfunction

" FUNCTION: Project.update(nerdtree) {{{1
function s:Project.update(nerdtree)
    "make sure the user hasn't browsed away from the project dir
    if !a:nerdtree.root.path.equals(self.getRootPath())
        return
    endif

    let self._openDirs = self._extractOpenDirs(a:nerdtree.root)
    call s:Project.Write()
endfunction

" vi: fdm=marker



autocmd VimLeave * :NERDTreeProjectSave project-1
